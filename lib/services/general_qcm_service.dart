import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/user_model.dart';
import '../models/general_qcm_model.dart';
import '../models/qcm_model.dart';
import '../models/course_model.dart';
import '../services/openai_service.dart';
import '../services/firestore_service.dart';
import '../utils/logger.dart';

/// Service pour gérer les QCM généraux adaptatifs basés sur le profil utilisateur
class GeneralQCMService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final OpenAIService _openAIService = OpenAIService();
  final FirestoreService _firestoreService = FirestoreService();

  /// Collection Firestore pour les QCM généraux
  static const String _collection = 'general_qcms';

  /// Obtenir les QCM généraux recommandés pour un utilisateur
  Future<List<GeneralQCMModel>> getRecommendedQCMs({
    required UserModel user,
    int limit = 5,
  }) async {
    try {
      List<String> userMatieres = _getUserSubjects(user);
      List<String>? userOptions = _getUserOptions(user);

      // Récupérer tous les QCM pour le niveau de l'utilisateur
      QuerySnapshot snapshot = await _firestore
          .collection(_collection)
          .where('niveau', isEqualTo: user.niveau)
          .get();

      List<GeneralQCMModel> allQCMs = snapshot.docs
          .map((doc) => GeneralQCMModel.fromFirestore(doc))
          .toList();

      // Filtrer et trier par pertinence
      List<GeneralQCMModel> relevantQCMs = allQCMs
          .where((qcm) => qcm.matchesUserProfile(
                userLevel: user.niveau,
                userMatieres: userMatieres,
                userOptions: userOptions,
              ))
          .toList();

      // Trier par score de pertinence
      relevantQCMs.sort((a, b) => b.getRelevanceScore(
            userLevel: user.niveau,
            userMatieres: userMatieres,
            userOptions: userOptions,
          ).compareTo(a.getRelevanceScore(
            userLevel: user.niveau,
            userMatieres: userMatieres,
            userOptions: userOptions,
          )));

      return relevantQCMs.take(limit).toList();
    } catch (e) {
      Logger.error('Erreur récupération QCM recommandés: $e');
      return [];
    }
  }

  /// Générer un nouveau QCM général pour un niveau et des matières spécifiques
  Future<GeneralQCMModel?> generateGeneralQCM({
    required String niveau,
    required List<String> matieres,
    List<String>? options,
    required QCMDifficulty difficulty,
    int numberOfQuestions = 15,
  }) async {
    try {
      // Créer un titre descriptif
      String titre = _buildQCMTitle(niveau, matieres, options, difficulty);
      String qcmId = _generateQCMId(niveau, matieres, options, difficulty);

      // Vérifier si ce QCM existe déjà
      DocumentSnapshot existing = await _firestore.collection(_collection).doc(qcmId).get();
      if (existing.exists) {
        Logger.info('QCM général existant: $qcmId');
        return GeneralQCMModel.fromFirestore(existing);
      }

      // Récupérer du contenu de plusieurs cours pour créer des questions variées
      List<CourseModel> sourceCourses = await _getSourceCourses(niveau, matieres, options);
      
      if (sourceCourses.isEmpty) {
        Logger.error('Aucun cours source trouvé pour générer le QCM général');
        return null;
      }

      // Générer le QCM avec OpenAI
      String combinedContent = _combineCoursesContent(sourceCourses);

      QCMModel? generatedQCM = await _openAIService.generateQCM(
        courseId: 'general_qcm',
        courseContent: combinedContent,
        title: titre,
        difficulty: difficulty,
        numberOfQuestions: numberOfQuestions,
      );

      if (generatedQCM == null) {
        Logger.error('Échec génération QCM général');
        return null;
      }

      // Convertir en GeneralQCMModel
      GeneralQCMModel generalQCM = GeneralQCMModel(
        id: qcmId,
        titre: titre,
        niveau: niveau,
        matieres: matieres,
        options: options,
        questions: generatedQCM.questions,
        difficulty: difficulty,
        minimumSuccessRate: _getMinimumSuccessRate(difficulty),
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        metadata: {
          'sourceCourses': sourceCourses.map((c) => c.id).toList(),
          'autoGenerated': true,
        },
      );

      // Sauvegarder dans Firestore
      await _firestore.collection(_collection).doc(qcmId).set(generalQCM.toFirestore());
      
      Logger.info('QCM général créé et sauvegardé: $qcmId');
      return generalQCM;
    } catch (e) {
      Logger.error('Erreur génération QCM général: $e');
      return null;
    }
  }

  /// Obtenir l'historique des QCM généraux terminés par un utilisateur
  Future<List<Map<String, dynamic>>> getQCMHistory({
    required String userId,
    int limit = 20,
  }) async {
    try {
      QuerySnapshot snapshot = await _firestore
          .collection('user_qcm_results')
          .where('userId', isEqualTo: userId)
          .where('qcmType', isEqualTo: 'general')
          .orderBy('completedAt', descending: true)
          .limit(limit)
          .get();

      List<Map<String, dynamic>> history = [];
      
      for (QueryDocumentSnapshot doc in snapshot.docs) {
        Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
        
        // Enrichir avec les détails du QCM si disponible
        String qcmId = data['qcmId'] ?? '';
        DocumentSnapshot qcmDoc = await _firestore.collection(_collection).doc(qcmId).get();
        
        Map<String, dynamic> historyItem = {
          ...data,
          'id': doc.id,
        };

        if (qcmDoc.exists) {
          GeneralQCMModel qcm = GeneralQCMModel.fromFirestore(qcmDoc);
          historyItem['qcmDetails'] = {
            'titre': qcm.titre,
            'niveau': qcm.niveau,
            'matieres': qcm.matieres,
            'difficulty': qcm.difficulty.name,
          };
        }

        history.add(historyItem);
      }

      return history;
    } catch (e) {
      Logger.error('Erreur récupération historique QCM: $e');
      return [];
    }
  }

  /// Enregistrer le résultat d'un QCM général
  Future<void> recordGeneralQCMResult({
    required String userId,
    required String qcmId,
    required double percentage,
    required bool passed,
    required int correctAnswers,
    required int totalQuestions,
    required bool xpAwarded,
  }) async {
    try {
      await _firestore.collection('user_qcm_results').add({
        'userId': userId,
        'qcmId': qcmId,
        'qcmType': 'general',
        'percentage': percentage,
        'passed': passed,
        'correctAnswers': correctAnswers,
        'totalQuestions': totalQuestions,
        'xpAwarded': xpAwarded,
        'completedAt': FieldValue.serverTimestamp(),
      });

      Logger.info('Résultat QCM général enregistré pour $userId: ${percentage.toStringAsFixed(1)}%');
    } catch (e) {
      Logger.error('Erreur enregistrement résultat QCM général: $e');
    }
  }

  /// Obtenir les statistiques globales des QCM généraux d'un utilisateur
  Future<Map<String, dynamic>> getUserQCMStats(String userId) async {
    try {
      QuerySnapshot snapshot = await _firestore
          .collection('user_qcm_results')
          .where('userId', isEqualTo: userId)
          .where('qcmType', isEqualTo: 'general')
          .get();

      if (snapshot.docs.isEmpty) {
        return {
          'totalAttempts': 0,
          'totalPassed': 0,
          'averageScore': 0.0,
          'totalXP': 0,
          'bestScore': 0.0,
          'recentActivity': [],
        };
      }

      List<Map<String, dynamic>> results = snapshot.docs
          .map((doc) => doc.data() as Map<String, dynamic>)
          .toList();

      int totalAttempts = results.length;
      int totalPassed = results.where((r) => r['passed'] == true).length;
      double averageScore = results.map((r) => r['percentage'] as double).reduce((a, b) => a + b) / totalAttempts;
      int totalXP = results.where((r) => r['xpAwarded'] == true).length * 10; // 10 XP par QCM réussi
      double bestScore = results.map((r) => r['percentage'] as double).reduce((a, b) => a > b ? a : b);

      return {
        'totalAttempts': totalAttempts,
        'totalPassed': totalPassed,
        'averageScore': averageScore,
        'totalXP': totalXP,
        'bestScore': bestScore,
        'successRate': totalAttempts > 0 ? (totalPassed / totalAttempts * 100) : 0.0,
      };
    } catch (e) {
      Logger.error('Erreur calcul statistiques QCM: $e');
      return {};
    }
  }

  /// Méthodes privées d'assistance
  
  List<String> _getUserSubjects(UserModel user) {
    // Matières standard par niveau
    Map<String, List<String>> standardSubjects = {
      'CP': ['Français', 'Mathématiques'],
      'CE1': ['Français', 'Mathématiques'],
      'CE2': ['Français', 'Mathématiques', 'Sciences'],
      'CM1': ['Français', 'Mathématiques', 'Sciences', 'Histoire-Géographie'],
      'CM2': ['Français', 'Mathématiques', 'Sciences', 'Histoire-Géographie'],
      '6ème': ['Français', 'Mathématiques', 'Histoire-Géographie', 'SVT', 'Anglais'],
      '5ème': ['Français', 'Mathématiques', 'Histoire-Géographie', 'SVT', 'Physique-Chimie', 'Anglais'],
      '4ème': ['Français', 'Mathématiques', 'Histoire-Géographie', 'SVT', 'Physique-Chimie', 'Anglais'],
      '3ème': ['Français', 'Mathématiques', 'Histoire-Géographie', 'SVT', 'Physique-Chimie', 'Anglais'],
      'Seconde': ['Français', 'Mathématiques', 'Histoire-Géographie', 'SVT', 'Physique-Chimie', 'Anglais'],
      'Première': ['Français', 'Histoire-Géographie', 'Anglais'],
      'Terminale': ['Philosophie', 'Histoire-Géographie', 'Anglais'],
    };

    return standardSubjects[user.niveau] ?? ['Français', 'Mathématiques'];
  }

  List<String>? _getUserOptions(UserModel user) {
    // Si l'utilisateur a des spécialisations/options renseignées
    return user.preferences['options'] as List<String>?;
  }

  String _buildQCMTitle(String niveau, List<String> matieres, List<String>? options, QCMDifficulty difficulty) {
    String title = 'QCM $niveau';
    if (options != null && options.isNotEmpty) {
      title += ' ${options.join('/')}';
    }
    title += ' - ${difficulty.name}';
    return title;
  }

  String _generateQCMId(String niveau, List<String> matieres, List<String>? options, QCMDifficulty difficulty) {
    String optionsStr = options != null && options.isNotEmpty ? '_${options.join('_')}' : '';
    String matieresStr = matieres.take(3).join('_').replaceAll(RegExp(r'[^a-zA-Z0-9_]'), '');
    return 'GENERAL_${niveau}_${matieresStr}${optionsStr}_${difficulty.name}';
  }

  Future<List<CourseModel>> _getSourceCourses(String niveau, List<String> matieres, List<String>? options) async {
    List<CourseModel> sourceCourses = [];
    
    for (String matiere in matieres.take(3)) { // Limiter à 3 matières
      try {
        List<CourseModel> courses = await _firestoreService.getCourses(
          matiere: matiere,
          niveau: niveau,
          limit: 2, // 2 cours par matière max
        );
        sourceCourses.addAll(courses);
      } catch (e) {
        Logger.error('Erreur récupération cours pour $matiere: $e');
      }
    }

    return sourceCourses;
  }

  String _combineCoursesContent(List<CourseModel> courses) {
    return courses.map((course) => '${course.title}:\n${course.content}\n---\n').join('\n');
  }


  int _getMinimumSuccessRate(QCMDifficulty difficulty) {
    switch (difficulty) {
      case QCMDifficulty.facile:
        return 60;
      case QCMDifficulty.moyen:
        return 70;
      case QCMDifficulty.difficile:
        return 75;
      case QCMDifficulty.tresDifficile:
        return 80;
    }
  }
}